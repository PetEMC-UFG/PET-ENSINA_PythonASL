# -*- coding: utf-8 -*-
"""EDO com TransfDeLaplace.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1NNFunpWrHyf1ANzfuwMSB8dUGJXThlaD
"""

# Commented out IPython magic to ensure Python compatibility.
# Exibir tudo no mesmo documento
# %matplotlib inline

# Trazer o módulo SymPy para o nosso programa
import sympy
from sympy.integrals.transforms import inverse_laplace_transform
from sympy import *
t = sympy.symbols('t')
c, C = sympy.symbols('c C', cls=Function)
s = sympy.symbols('s')

# Print mais bonito no SymPy
init_printing(use_unicode=True)

# Condicoes Iniciais - NULAS
y0 = 0
dy_0 = 0

# Defina aqui a equação diferencial no domínio 's'
# s^2C(s)-sy(0)-y'(0) + 6(sC(s)-y(0)) + 2C(s) = 2(sR(s)-y(0)) + R(s)
equacao_em_s  = Eq(((s**2)*C(s)-s*y0-dy_0)+12*(s*C(s)-y0)+32*C(s), 2/(s**3))

# Resolve a equação para G(s) = C(s) / R(s)
G_s = solve(equacao_em_s, C(s))

print(G_s[0])


# Faz a Transformada Inversa de Laplace da função de transferência G(s)
solucao = inverse_laplace_transform(G_s[0], s, t)
print('\n\n\n\n')

# Resposta formatada de maneira expandida e melhorada
solucao.expand()