# -*- coding: utf-8 -*-
"""calculo_TransfLaplace.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1b0dm23traTeIYeRuSHBuY0Ix5546InBX
"""

# Commented out IPython magic to ensure Python compatibility.
# Importando o módulo SymPy
import sympy as sp
from sympy import *
# %matplotlib inline
init_printing(use_unicode=True)

# Definindo os símbolos usados na Transformada de Laplace
t, s = sp.symbols('t, s')
a = sp.symbols('a', real=True, positive=True)
exp = sp.exp # exponencial na base e (Euler)
sin = sp.sin # função seno
cos = sp.cos # função cosseno
coship = sp.cosh # função cosseno hiperbólico
senhip = sp.sinh # função seno hiperbólico

# Definindo a função do SymPy que executa a Transformada de Laplace
def Laplace(f):
  return sp.laplace_transform(f, t, s, noconds=True)

# Valor do coeficiente 'a'
a = 1

# Especificar a função 'f(t)' a ser calculada
f = ((1/32)-(1/16)*exp(-4*t)+(1/32)*exp(-8*t))

# Também pode ser definido um vetor de funções f(t), f_2(t), ..., f_n(t)
# funcoes = [exp(-2*t), sin(3*t), exp(1*t)*cos(1*t), coship(7*t)]

#func_ex = [exp(3*t)*cos(2*t), (t**5)*exp(4*t), sin(5*t)*cos(6*t), (t**2)*sin(7*t), senhip(t)]

# Cálculo da Transformada de Laplace da função 'f' especificada anteriormente
Fs = Laplace(f)

# Caso tenhamos um vetor de funções, deve-se usar a sintaxe a seguir:
#Fs = [Laplace(f) for f in func_ex]

# Retorna o resultado da Transformada de Laplace
Fs